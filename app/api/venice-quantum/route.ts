import { type NextRequest, NextResponse } from "next/server"
import { veniceQuantumVerifier } from "@/lib/venice-ai-quantum-verifier"

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { action, data, moveData, cryptoToken, marketCondition, opponentToken } = body

    switch (action) {
      case "encrypt_data":
        if (!data) {
          return NextResponse.json({ error: "Data parameter required for encryption" }, { status: 400 })
        }

        const encryptedData = await veniceQuantumVerifier.encryptWithAllLayers(data)
        return NextResponse.json({
          success: true,
          encrypted: encryptedData,
          layers: 5,
          message: "Data encrypted with 5-layer Undead$stackerS system",
        })

      case "validate_move":
        if (!moveData) {
          return NextResponse.json({ error: "Move data required for validation" }, { status: 400 })
        }

        const boxerStats = {
          health: 100,
          energy: 80,
          cryptoAffinity: moveData.cryptoToken || "BTC",
          marketSentiment: 0.7,
          koCount: 0,
          wyomingCompliance: true,
        }

        const isValid = await veniceQuantumVerifier.validateCombatMove(moveData, boxerStats)
        return NextResponse.json({
          success: true,
          valid: isValid,
          move: moveData,
          message: isValid ? "Move validated by Wyoming DAO" : "Move rejected by compliance",
        })

      case "generate_strategy":
        if (!cryptoToken || !marketCondition) {
          return NextResponse.json(
            { error: "cryptoToken and marketCondition required for strategy generation" },
            { status: 400 },
          )
        }

        const strategy = await veniceQuantumVerifier.generateCombatStrategy(
          cryptoToken,
          marketCondition,
          opponentToken || "ETH",
        )

        return NextResponse.json({
          success: true,
          strategy,
          cryptoToken,
          marketCondition,
          message: "Combat strategy generated by Venice AI",
        })

      case "verify_integration":
        const verification = await veniceQuantumVerifier.verifyCompleteIntegration()
        return NextResponse.json({
          success: true,
          verification,
          message: `Integration ${verification.overallScore}% complete`,
        })

      case "hackathon_signature":
        const signature = veniceQuantumVerifier.generateHackathonSignature()
        return NextResponse.json({
          success: true,
          signature,
          timestamp: new Date().toISOString(),
          message: "Hackathon submission signature generated",
        })

      case "quantum_test":
        // Test all quantum layers
        const testData = "WyoVerse Quantum Test " + Date.now()
        const quantumResult = await veniceQuantumVerifier.encryptWithAllLayers(testData)

        const layers = {
          layer1: quantumResult.includes(":"),
          layer2: quantumResult.includes("UND3AD"),
          layer3: quantumResult.includes("QUANTUM"),
          layer4: quantumResult.includes("ALEO"),
          layer5: quantumResult.includes("WYOMING"),
        }

        const layerCount = Object.values(layers).filter(Boolean).length

        return NextResponse.json({
          success: true,
          layers,
          layerCount,
          quantumResult: quantumResult.substring(0, 100) + "...",
          message: `${layerCount}/5 quantum layers active`,
        })

      default:
        return NextResponse.json(
          {
            error: "Invalid action",
            available_actions: [
              "encrypt_data",
              "validate_move",
              "generate_strategy",
              "verify_integration",
              "hackathon_signature",
              "quantum_test",
            ],
          },
          { status: 400 },
        )
    }
  } catch (error) {
    console.error("Venice Quantum API error:", error)

    return NextResponse.json(
      {
        success: false,
        error: "Venice Quantum operation failed",
        message: "Something went wrong with the quantum operation, partner.",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    )
  }
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url)
  const test = url.searchParams.get("test")

  try {
    if (test === "quick") {
      // Quick integration test
      const verification = await veniceQuantumVerifier.verifyCompleteIntegration()
      return NextResponse.json({
        status: "operational",
        integration_score: verification.overallScore,
        venice_ai: verification.veniceAI ? "✅" : "❌",
        quantum_layers: verification.quantumLayers ? "✅" : "❌",
        wyoming_compliance: verification.wyomingCompliance ? "✅" : "❌",
        aleo_proofs: verification.aleoProofs ? "✅" : "❌",
        undead_encryption: verification.undeadEncryption ? "✅" : "❌",
      })
    } else {
      // Return service status
      return NextResponse.json({
        status: "operational",
        version: "1.0.0",
        venice_ai_model: "llama-3.1-8b",
        quantum_layers: 5,
        encryption_system: "Undead$stackerS",
        wyoming_compliant: true,
        aleo_integrated: true,
        available_actions: [
          "encrypt_data",
          "validate_move",
          "generate_strategy",
          "verify_integration",
          "hackathon_signature",
          "quantum_test",
        ],
        last_verification: new Date().toISOString(),
      })
    }
  } catch (error) {
    return NextResponse.json(
      {
        error: "Venice Quantum service error",
        message: "Could not process quantum request",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    )
  }
}
